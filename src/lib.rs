pub mod extension_set;

use core::{f32, slice};
use std::ffi::CStr;

use extension_set::ext_set_from_names;
use glam::{Quat, Vec3};
use openxr::HandJoint;
use quark::{
    openxr::{
        self,
        sys::{Instance, InstanceCreateInfo},
        Entry,
    },
    prelude::*,
    APILayerInstanceData,
};

// put this in your main file!
quark::api_layer! {
    // whatever struct you wanna use for your main instance data
    instance_data: InstanceData,
    // any functions to override, don't forget the destroy functions for everything you add data to (except instance, that's already handled)!
    override_fns: {
        // <openxr function name>: <rust function name>
        xrCreateHandTrackerEXT: create_tracker,
        xrDestroyHandTrackerEXT: xr_destroy_hand_tracker_ext, // generated by the handle macro
        xrCreateSession: create_session,
        xrDestroySession: xr_destroy_session, // generated by the handle macro
        xrLocateHandJointsEXT: locate_joints
    }
}

// put this for all your data structs for handles, will automatically create a destroy function for them
#[quark::handle(openxr::sys::Instance)]
pub struct InstanceData {
    instance: openxr::Instance,
}
// this is so we can have the api_layer! macro do all the sensitive work for us and we can goof around :p
impl APILayerInstanceData for InstanceData {
    // you can get the data back from any `Instance` handle by just going `instance.data()?`
    fn create(
        entry: Entry,
        instance_info: &InstanceCreateInfo,
        instance: Instance,
    ) -> XrResult<Self> {
        let instance = unsafe {
            let w = slice::from_raw_parts(
                instance_info.enabled_extension_names,
                instance_info.enabled_extension_count as usize,
            );
            let w = w.iter().map(|v| CStr::from_ptr(*v)).collect::<Vec<_>>();
            let instance_extension =
                openxr::InstanceExtensions::load(&entry, instance, &ext_set_from_names(&w))?;
            openxr::Instance::from_raw(entry, instance, instance_extension)
        }?;
        Ok(InstanceData { instance })
    }
    // need to give this back for `xrGetInstanceProcAddr`, wanted to avoid a wrapper type that'd complicate stuff
    fn entry(&self) -> &Entry {
        self.instance.entry()
    }
}
#[quark::handle(openxr::sys::Session)]
pub struct SessionData {
    instance: openxr::Instance,
}

#[quark::wrap_openxr]
fn create_session(
    instance: openxr::sys::Instance,
    create_info: &openxr::sys::SessionCreateInfo,
    session: &mut openxr::sys::Session,
) -> XrResult {
    let oxr_instance = &instance.data()?.instance;
    cvt(|| unsafe { (oxr_instance.fp().create_session)(instance, create_info, session) })?;
    session.add_data(SessionData {
        instance: oxr_instance.clone(),
    });
    XrResult::Ok(())
}

#[quark::wrap_openxr]
fn locate_joints(
    hand_tracker: openxr::sys::HandTrackerEXT,
    locate_info: &openxr::sys::HandJointsLocateInfoEXT,
    locations: &mut openxr::sys::HandJointLocationsEXT,
) -> XrResult {
    let instance = hand_tracker.data()?.instance.clone();
    cvt(|| unsafe {
        (instance
            .exts()
            .ext_hand_tracking
            .as_ref()
            .unwrap()
            .locate_hand_joints)(hand_tracker, locate_info, locations)
    })?;
    let slice = unsafe {
        slice::from_raw_parts_mut(locations.joint_locations, locations.joint_count as usize)
    };
    slice.iter_mut().enumerate().for_each(|(id, joint)| {
        if [
            HandJoint::THUMB_TIP,
            HandJoint::THUMB_PROXIMAL,
            HandJoint::THUMB_METACARPAL,
            HandJoint::THUMB_DISTAL,
        ]
        .iter()
        .any(|v| v.into_raw() as usize == id)
            && joint
                .location_flags
                .contains(openxr::SpaceLocationFlags::ORIENTATION_VALID)
        {
            let quat = Quat::from(mint::Quaternion::from(joint.pose.orientation));
            let Ok(data) = hand_tracker.data() else {
                return;
            };

            let quat = quat
                * Quat::from_rotation_z(
                    f32::consts::FRAC_PI_2
                        * match data.side {
                            Side::Left => -1.0,
                            Side::Right => 1.0,
                        },
                );
            joint.pose.orientation = mint::Quaternion::from(quat).into()
        };
        if [
            HandJoint::THUMB_TIP,
            HandJoint::INDEX_TIP,
            HandJoint::MIDDLE_TIP,
            HandJoint::RING_TIP,
            HandJoint::LITTLE_TIP,
        ]
        .iter()
        .any(|v| v.into_raw() as usize == id)
            && joint.location_flags.contains(
                openxr::SpaceLocationFlags::POSITION_VALID
                    | openxr::SpaceLocationFlags::ORIENTATION_VALID,
            )
        {
            let quat = Quat::from(mint::Quaternion::from(joint.pose.orientation));
            let mut vec = Vec3::from(mint::Vector3::from(joint.pose.position));
            vec += quat * (Vec3::Z * joint.radius);

            joint.pose.position = mint::Vector3::from(vec).into();
            joint.pose.orientation = mint::Quaternion::from(quat).into();
        };
    });

    XrResult::Ok(())
}

#[derive(Clone)]
enum Side {
    Left,
    Right,
}

#[quark::handle(openxr::sys::HandTrackerEXT)]
pub struct HandtrackerData {
    side: Side,
    instance: openxr::Instance,
}
#[quark::wrap_openxr]
pub fn create_tracker(
    session: openxr::sys::Session,
    create_info: &openxr::sys::HandTrackerCreateInfoEXT,
    tracker: &mut openxr::sys::HandTrackerEXT,
) -> XrResult {
    let instance = session.data()?.instance.clone();
    if let Some(ext_hand_tracking) = instance.exts().ext_hand_tracking.as_ref() {
        cvt(|| unsafe { (ext_hand_tracking.create_hand_tracker)(session, create_info, tracker) })?;
    }
    tracker.add_data(HandtrackerData {
        instance,
        side: match create_info.hand {
            openxr::sys::HandEXT::LEFT => Side::Left,
            openxr::sys::HandEXT::RIGHT => Side::Right,
            _ => unreachable!(),
        },
    });

    XrResult::Ok(())
}
